/**
 * æµ‹è¯•æŠ¥å‘Šç”Ÿæˆå™¨
 * Test Report Generator for ZiWei Core
 */

import * as fs from 'fs'
import * as path from 'path'

interface TestResult {
  suite: string
  tests: {
    name: string
    status: 'passed' | 'failed' | 'skipped'
    duration: number
    error?: string
  }[]
  duration: number
  passed: number
  failed: number
  skipped: number
}

interface PerformanceMetric {
  name: string
  mean: number
  median: number
  p95: number
  p99: number
  min: number
  max: number
}

interface CoverageReport {
  lines: number
  branches: number
  functions: number
  statements: number
}

export class TestReportGenerator {
  private results: TestResult[] = []
  private performanceMetrics: PerformanceMetric[] = []
  private coverage?: CoverageReport
  private startTime: Date
  private endTime?: Date
  
  constructor() {
    this.startTime = new Date()
  }
  
  /**
   * æ·»åŠ æµ‹è¯•ç»“æœ
   */
  addTestResult(result: TestResult): void {
    this.results.push(result)
  }
  
  /**
   * æ·»åŠ æ€§èƒ½æŒ‡æ ‡
   */
  addPerformanceMetric(metric: PerformanceMetric): void {
    this.performanceMetrics.push(metric)
  }
  
  /**
   * è®¾ç½®è¦†ç›–ç‡æŠ¥å‘Š
   */
  setCoverageReport(coverage: CoverageReport): void {
    this.coverage = coverage
  }
  
  /**
   * ç”ŸæˆMarkdownæ ¼å¼çš„æŠ¥å‘Š
   */
  generateMarkdownReport(): string {
    this.endTime = new Date()
    
    const report: string[] = []
    
    // æŠ¥å‘Šå¤´éƒ¨
    report.push('# ç´«å¾®æ–—æ•°æ ¸å¿ƒåº“æµ‹è¯•æŠ¥å‘Š')
    report.push(`# ZiWei Core Test Report`)
    report.push('')
    report.push(`**ç”Ÿæˆæ—¶é—´**: ${this.endTime.toLocaleString('zh-CN')}`)
    report.push(`**æµ‹è¯•æ—¶é•¿**: ${this.getTestDuration()}`)
    report.push('')
    
    // æ‰§è¡Œæ‘˜è¦
    report.push('## ğŸ“Š æ‰§è¡Œæ‘˜è¦ (Executive Summary)')
    report.push('')
    report.push(this.generateSummaryTable())
    report.push('')
    
    // æµ‹è¯•è¦†ç›–ç‡
    if (this.coverage) {
      report.push('## ğŸ“ˆ æµ‹è¯•è¦†ç›–ç‡ (Test Coverage)')
      report.push('')
      report.push(this.generateCoverageTable())
      report.push('')
    }
    
    // æ€§èƒ½æŒ‡æ ‡
    if (this.performanceMetrics.length > 0) {
      report.push('## âš¡ æ€§èƒ½æŒ‡æ ‡ (Performance Metrics)')
      report.push('')
      report.push(this.generatePerformanceTable())
      report.push('')
    }
    
    // è¯¦ç»†æµ‹è¯•ç»“æœ
    report.push('## ğŸ§ª è¯¦ç»†æµ‹è¯•ç»“æœ (Detailed Test Results)')
    report.push('')
    
    this.results.forEach(suite => {
      report.push(`### ${suite.suite}`)
      report.push('')
      report.push(this.generateSuiteTable(suite))
      report.push('')
    })
    
    // å¤±è´¥çš„æµ‹è¯•
    const failedTests = this.getFailedTests()
    if (failedTests.length > 0) {
      report.push('## âŒ å¤±è´¥çš„æµ‹è¯• (Failed Tests)')
      report.push('')
      failedTests.forEach(test => {
        report.push(`- **${test.suite}** > ${test.name}`)
        if (test.error) {
          report.push(`  - é”™è¯¯: ${test.error}`)
        }
      })
      report.push('')
    }
    
    // å»ºè®®å’Œä¸‹ä¸€æ­¥
    report.push('## ğŸ’¡ å»ºè®®ä¸æ”¹è¿› (Recommendations)')
    report.push('')
    report.push(this.generateRecommendations())
    report.push('')
    
    // é¡µè„š
    report.push('---')
    report.push('*Generated by ZiWei Core Test Report Generator*')
    
    return report.join('\n')
  }
  
  /**
   * ç”ŸæˆHTMLæ ¼å¼çš„æŠ¥å‘Š
   */
  generateHTMLReport(): string {
    this.endTime = new Date()
    
    const html: string[] = []
    
    html.push('<!DOCTYPE html>')
    html.push('<html lang="zh-CN">')
    html.push('<head>')
    html.push('  <meta charset="UTF-8">')
    html.push('  <meta name="viewport" content="width=device-width, initial-scale=1.0">')
    html.push('  <title>ç´«å¾®æ–—æ•°æ ¸å¿ƒåº“æµ‹è¯•æŠ¥å‘Š</title>')
    html.push('  <style>')
    html.push(this.getHTMLStyles())
    html.push('  </style>')
    html.push('</head>')
    html.push('<body>')
    html.push('  <div class="container">')
    
    // æ ‡é¢˜
    html.push('    <h1>ç´«å¾®æ–—æ•°æ ¸å¿ƒåº“æµ‹è¯•æŠ¥å‘Š</h1>')
    html.push(`    <p class="subtitle">ç”Ÿæˆæ—¶é—´: ${this.endTime.toLocaleString('zh-CN')}</p>`)
    
    // æ‘˜è¦å¡ç‰‡
    html.push('    <div class="summary-cards">')
    html.push(this.generateSummaryCards())
    html.push('    </div>')
    
    // æµ‹è¯•è¦†ç›–ç‡å›¾è¡¨
    if (this.coverage) {
      html.push('    <section class="coverage">')
      html.push('      <h2>æµ‹è¯•è¦†ç›–ç‡</h2>')
      html.push(this.generateCoverageChart())
      html.push('    </section>')
    }
    
    // æ€§èƒ½æŒ‡æ ‡
    if (this.performanceMetrics.length > 0) {
      html.push('    <section class="performance">')
      html.push('      <h2>æ€§èƒ½æŒ‡æ ‡</h2>')
      html.push(this.generatePerformanceChart())
      html.push('    </section>')
    }
    
    // æµ‹è¯•ç»“æœè¯¦æƒ…
    html.push('    <section class="test-results">')
    html.push('      <h2>æµ‹è¯•ç»“æœè¯¦æƒ…</h2>')
    this.results.forEach(suite => {
      html.push(this.generateSuiteHTML(suite))
    })
    html.push('    </section>')
    
    html.push('  </div>')
    html.push('</body>')
    html.push('</html>')
    
    return html.join('\n')
  }
  
  /**
   * ä¿å­˜æŠ¥å‘Šåˆ°æ–‡ä»¶
   */
  saveReport(outputPath: string, format: 'markdown' | 'html' = 'markdown'): void {
    const content = format === 'markdown' 
      ? this.generateMarkdownReport()
      : this.generateHTMLReport()
    
    const extension = format === 'markdown' ? '.md' : '.html'
    const fileName = `test-report-${Date.now()}${extension}`
    const filePath = path.join(outputPath, fileName)
    
    fs.writeFileSync(filePath, content, 'utf-8')
    console.log(`æµ‹è¯•æŠ¥å‘Šå·²ä¿å­˜åˆ°: ${filePath}`)
  }
  
  // ç§æœ‰è¾…åŠ©æ–¹æ³•
  
  private getTestDuration(): string {
    if (!this.endTime) return 'N/A'
    const duration = this.endTime.getTime() - this.startTime.getTime()
    const seconds = Math.floor(duration / 1000)
    const minutes = Math.floor(seconds / 60)
    const hours = Math.floor(minutes / 60)
    
    if (hours > 0) {
      return `${hours}å°æ—¶ ${minutes % 60}åˆ†é’Ÿ ${seconds % 60}ç§’`
    } else if (minutes > 0) {
      return `${minutes}åˆ†é’Ÿ ${seconds % 60}ç§’`
    } else {
      return `${seconds}ç§’`
    }
  }
  
  private generateSummaryTable(): string {
    const total = this.results.reduce((acc, r) => ({
      tests: acc.tests + r.tests.length,
      passed: acc.passed + r.passed,
      failed: acc.failed + r.failed,
      skipped: acc.skipped + r.skipped
    }), { tests: 0, passed: 0, failed: 0, skipped: 0 })
    
    const passRate = ((total.passed / total.tests) * 100).toFixed(2)
    
    return `| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| æ€»æµ‹è¯•æ•° | ${total.tests} |
| é€šè¿‡ | ${total.passed} âœ… |
| å¤±è´¥ | ${total.failed} âŒ |
| è·³è¿‡ | ${total.skipped} â­ï¸ |
| é€šè¿‡ç‡ | ${passRate}% |
| æµ‹è¯•å¥—ä»¶æ•° | ${this.results.length} |`
  }
  
  private generateCoverageTable(): string {
    if (!this.coverage) return ''
    
    return `| ç±»å‹ | è¦†ç›–ç‡ |
|------|--------|
| è¡Œè¦†ç›–ç‡ | ${this.coverage.lines}% |
| åˆ†æ”¯è¦†ç›–ç‡ | ${this.coverage.branches}% |
| å‡½æ•°è¦†ç›–ç‡ | ${this.coverage.functions}% |
| è¯­å¥è¦†ç›–ç‡ | ${this.coverage.statements}% |`
  }
  
  private generatePerformanceTable(): string {
    const rows = this.performanceMetrics.map(metric => 
      `| ${metric.name} | ${metric.mean.toFixed(2)}ms | ${metric.median.toFixed(2)}ms | ${metric.p95.toFixed(2)}ms | ${metric.p99.toFixed(2)}ms |`
    )
    
    return `| æµ‹è¯•é¡¹ | å¹³å‡å€¼ | ä¸­ä½æ•° | P95 | P99 |
|--------|--------|--------|-----|-----|
${rows.join('\n')}`
  }
  
  private generateSuiteTable(suite: TestResult): string {
    const rows = suite.tests.map(test => {
      const status = test.status === 'passed' ? 'âœ…' 
        : test.status === 'failed' ? 'âŒ' 
        : 'â­ï¸'
      return `| ${test.name} | ${status} | ${test.duration.toFixed(2)}ms |`
    })
    
    return `| æµ‹è¯•åç§° | çŠ¶æ€ | è€—æ—¶ |
|----------|------|------|
${rows.join('\n')}

**å¥—ä»¶ç»Ÿè®¡**: é€šè¿‡ ${suite.passed} | å¤±è´¥ ${suite.failed} | è·³è¿‡ ${suite.skipped} | æ€»è€—æ—¶ ${suite.duration.toFixed(2)}ms`
  }
  
  private getFailedTests() {
    const failed: any[] = []
    this.results.forEach(suite => {
      suite.tests.forEach(test => {
        if (test.status === 'failed') {
          failed.push({
            suite: suite.suite,
            name: test.name,
            error: test.error
          })
        }
      })
    })
    return failed
  }
  
  private generateRecommendations(): string {
    const recommendations: string[] = []
    
    // åŸºäºè¦†ç›–ç‡çš„å»ºè®®
    if (this.coverage) {
      if (this.coverage.lines < 80) {
        recommendations.push('- ğŸ“ è¡Œè¦†ç›–ç‡ä½äº80%ï¼Œå»ºè®®å¢åŠ æ›´å¤šå•å…ƒæµ‹è¯•')
      }
      if (this.coverage.branches < 70) {
        recommendations.push('- ğŸŒ¿ åˆ†æ”¯è¦†ç›–ç‡ä½äº70%ï¼Œå»ºè®®è¦†ç›–æ›´å¤šæ¡ä»¶åˆ†æ”¯')
      }
    }
    
    // åŸºäºæ€§èƒ½çš„å»ºè®®
    const slowTests = this.performanceMetrics.filter(m => m.p95 > 100)
    if (slowTests.length > 0) {
      recommendations.push(`- âš¡ ${slowTests.length}ä¸ªæµ‹è¯•çš„P95å“åº”æ—¶é—´è¶…è¿‡100msï¼Œå»ºè®®ä¼˜åŒ–`)
    }
    
    // åŸºäºå¤±è´¥æµ‹è¯•çš„å»ºè®®
    const failedCount = this.getFailedTests().length
    if (failedCount > 0) {
      recommendations.push(`- ğŸ”§ æœ‰${failedCount}ä¸ªæµ‹è¯•å¤±è´¥ï¼Œéœ€è¦ç«‹å³ä¿®å¤`)
    }
    
    if (recommendations.length === 0) {
      recommendations.push('- âœ¨ æµ‹è¯•ç»“æœè‰¯å¥½ï¼Œç»§ç»­ä¿æŒï¼')
    }
    
    return recommendations.join('\n')
  }
  
  private getHTMLStyles(): string {
    return `
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: white;
        min-height: 100vh;
      }
      h1 {
        color: #2d3748;
        border-bottom: 3px solid #667eea;
        padding-bottom: 10px;
      }
      .subtitle {
        color: #718096;
        font-size: 14px;
      }
      .summary-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin: 30px 0;
      }
      .card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .card h3 {
        margin: 0 0 10px 0;
        font-size: 14px;
        opacity: 0.9;
      }
      .card .value {
        font-size: 32px;
        font-weight: bold;
      }
      .card .unit {
        font-size: 14px;
        opacity: 0.9;
      }
      section {
        margin: 40px 0;
      }
      h2 {
        color: #2d3748;
        border-left: 4px solid #667eea;
        padding-left: 10px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
      }
      th {
        background: #f7fafc;
        padding: 12px;
        text-align: left;
        border-bottom: 2px solid #e2e8f0;
      }
      td {
        padding: 12px;
        border-bottom: 1px solid #e2e8f0;
      }
      .passed { color: #48bb78; }
      .failed { color: #f56565; }
      .skipped { color: #ed8936; }
      .coverage-bar {
        background: #e2e8f0;
        border-radius: 4px;
        height: 20px;
        overflow: hidden;
        margin: 5px 0;
      }
      .coverage-fill {
        height: 100%;
        background: linear-gradient(90deg, #48bb78 0%, #38a169 100%);
        transition: width 0.3s ease;
      }
    `
  }
  
  private generateSummaryCards(): string {
    const total = this.results.reduce((acc, r) => ({
      tests: acc.tests + r.tests.length,
      passed: acc.passed + r.passed,
      failed: acc.failed + r.failed,
      skipped: acc.skipped + r.skipped
    }), { tests: 0, passed: 0, failed: 0, skipped: 0 })
    
    const passRate = ((total.passed / total.tests) * 100).toFixed(1)
    
    return `
      <div class="card">
        <h3>æ€»æµ‹è¯•æ•°</h3>
        <div class="value">${total.tests}</div>
      </div>
      <div class="card">
        <h3>é€šè¿‡ç‡</h3>
        <div class="value">${passRate}<span class="unit">%</span></div>
      </div>
      <div class="card">
        <h3>é€šè¿‡</h3>
        <div class="value passed">${total.passed}</div>
      </div>
      <div class="card">
        <h3>å¤±è´¥</h3>
        <div class="value failed">${total.failed}</div>
      </div>
    `
  }
  
  private generateCoverageChart(): string {
    if (!this.coverage) return ''
    
    return `
      <div class="coverage-chart">
        <div class="coverage-item">
          <div class="coverage-label">è¡Œè¦†ç›–ç‡</div>
          <div class="coverage-bar">
            <div class="coverage-fill" style="width: ${this.coverage.lines}%"></div>
          </div>
          <div class="coverage-value">${this.coverage.lines}%</div>
        </div>
        <div class="coverage-item">
          <div class="coverage-label">åˆ†æ”¯è¦†ç›–ç‡</div>
          <div class="coverage-bar">
            <div class="coverage-fill" style="width: ${this.coverage.branches}%"></div>
          </div>
          <div class="coverage-value">${this.coverage.branches}%</div>
        </div>
        <div class="coverage-item">
          <div class="coverage-label">å‡½æ•°è¦†ç›–ç‡</div>
          <div class="coverage-bar">
            <div class="coverage-fill" style="width: ${this.coverage.functions}%"></div>
          </div>
          <div class="coverage-value">${this.coverage.functions}%</div>
        </div>
        <div class="coverage-item">
          <div class="coverage-label">è¯­å¥è¦†ç›–ç‡</div>
          <div class="coverage-bar">
            <div class="coverage-fill" style="width: ${this.coverage.statements}%"></div>
          </div>
          <div class="coverage-value">${this.coverage.statements}%</div>
        </div>
      </div>
    `
  }
  
  private generatePerformanceChart(): string {
    const rows = this.performanceMetrics.map(metric => `
      <tr>
        <td>${metric.name}</td>
        <td>${metric.mean.toFixed(2)}ms</td>
        <td>${metric.median.toFixed(2)}ms</td>
        <td>${metric.p95.toFixed(2)}ms</td>
        <td>${metric.p99.toFixed(2)}ms</td>
        <td>${metric.min.toFixed(2)}ms</td>
        <td>${metric.max.toFixed(2)}ms</td>
      </tr>
    `).join('')
    
    return `
      <table>
        <thead>
          <tr>
            <th>æµ‹è¯•é¡¹</th>
            <th>å¹³å‡å€¼</th>
            <th>ä¸­ä½æ•°</th>
            <th>P95</th>
            <th>P99</th>
            <th>æœ€å°å€¼</th>
            <th>æœ€å¤§å€¼</th>
          </tr>
        </thead>
        <tbody>
          ${rows}
        </tbody>
      </table>
    `
  }
  
  private generateSuiteHTML(suite: TestResult): string {
    const rows = suite.tests.map(test => {
      const statusClass = test.status
      const statusIcon = test.status === 'passed' ? 'âœ…' 
        : test.status === 'failed' ? 'âŒ' 
        : 'â­ï¸'
      
      return `
        <tr>
          <td>${test.name}</td>
          <td class="${statusClass}">${statusIcon} ${test.status}</td>
          <td>${test.duration.toFixed(2)}ms</td>
        </tr>
      `
    }).join('')
    
    return `
      <div class="test-suite">
        <h3>${suite.suite}</h3>
        <table>
          <thead>
            <tr>
              <th>æµ‹è¯•åç§°</th>
              <th>çŠ¶æ€</th>
              <th>è€—æ—¶</th>
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>
        <p class="suite-summary">
          é€šè¿‡: <span class="passed">${suite.passed}</span> | 
          å¤±è´¥: <span class="failed">${suite.failed}</span> | 
          è·³è¿‡: <span class="skipped">${suite.skipped}</span> | 
          æ€»è€—æ—¶: ${suite.duration.toFixed(2)}ms
        </p>
      </div>
    `
  }
}

// å¯¼å‡ºä½¿ç”¨ç¤ºä¾‹
export function generateTestReport() {
  const generator = new TestReportGenerator()
  
  // æ·»åŠ æµ‹è¯•ç»“æœç¤ºä¾‹
  generator.addTestResult({
    suite: 'å®«ä½å…³ç³»æµ‹è¯•',
    tests: [
      { name: 'ä¸‰åˆå®«è®¡ç®—', status: 'passed', duration: 0.5 },
      { name: 'å››æ­£å®«è®¡ç®—', status: 'passed', duration: 0.3 },
      { name: 'æœ¬ä½“å®«è®¡ç®—', status: 'passed', duration: 0.4 }
    ],
    duration: 1.2,
    passed: 3,
    failed: 0,
    skipped: 0
  })
  
  // æ·»åŠ æ€§èƒ½æŒ‡æ ‡ç¤ºä¾‹
  generator.addPerformanceMetric({
    name: 'å‘½ç›˜è®¡ç®—',
    mean: 45.2,
    median: 42.0,
    p95: 78.5,
    p99: 95.2,
    min: 28.1,
    max: 112.3
  })
  
  // è®¾ç½®è¦†ç›–ç‡
  generator.setCoverageReport({
    lines: 85,
    branches: 78,
    functions: 92,
    statements: 87
  })
  
  // ç”Ÿæˆå¹¶ä¿å­˜æŠ¥å‘Š
  const outputPath = path.join(__dirname, '../../../reports')
  generator.saveReport(outputPath, 'markdown')
  generator.saveReport(outputPath, 'html')
}